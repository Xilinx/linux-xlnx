menu "Kernel hacking"

source "lib/Kconfig.debug"

config STRICT_DEVMEM
	bool "Filter access to /dev/mem"
	depends on MMU
	---help---
	  If this option is disabled, you allow userspace (root) access to all
	  of memory, including kernel and userspace memory. Accidental
	  access to this is obviously disastrous, but specific access can
	  be used by people debugging the kernel.

	  If this option is switched on, the /dev/mem file only allows
	  userspace access to memory mapped peripherals.

          If in doubt, say Y.

# RMK wants arm kernels compiled with frame pointers or stack unwinding.
# If you know what you are doing and are willing to live without stack
# traces, you can get a slightly smaller kernel by setting this option to
# n, but then RMK will have to kill you ;).
config FRAME_POINTER
	bool
	depends on !THUMB2_KERNEL
	default y if !ARM_UNWIND || FUNCTION_GRAPH_TRACER
	help
	  If you say N here, the resulting kernel will be slightly smaller and
	  faster. However, if neither FRAME_POINTER nor ARM_UNWIND are enabled,
	  when a problem occurs with the kernel, the information that is
	  reported is severely limited.

config ARM_UNWIND
	bool "Enable stack unwinding support (EXPERIMENTAL)"
	depends on AEABI
	default y
	help
	  This option enables stack unwinding support in the kernel
	  using the information automatically generated by the
	  compiler. The resulting kernel image is slightly bigger but
	  the performance is not affected. Currently, this feature
	  only works with EABI compilers. If unsure say Y.

config OLD_MCOUNT
	bool
	depends on FUNCTION_TRACER && FRAME_POINTER
	default y

config DEBUG_USER
	bool "Verbose user fault messages"
	help
	  When a user program crashes due to an exception, the kernel can
	  print a brief message explaining what the problem was. This is
	  sometimes helpful for debugging but serves no purpose on a
	  production system. Most people should say N here.

	  In addition, you need to pass user_debug=N on the kernel command
	  line to enable this feature.  N consists of the sum of:

	      1 - undefined instruction events
	      2 - system calls
	      4 - invalid data aborts
	      8 - SIGSEGV faults
	     16 - SIGBUS faults

# These options are only for real kernel hackers who want to get their hands dirty.
config DEBUG_LL
	bool "Kernel low-level debugging functions (read help!)"
	depends on DEBUG_KERNEL
	help
	  Say Y here to include definitions of printascii, printch, printhex
	  in the kernel.  This is helpful if you are debugging code that
	  executes before the console is initialized.

	  Note that selecting this option will limit the kernel to a single
	  UART definition, as specified below. Attempting to boot the kernel
	  image on a different platform *will not work*, so this option should
	  not be enabled for kernels that are intended to be portable.

choice
	prompt "Kernel low-level debugging port"
	depends on DEBUG_LL

	config AT91_DEBUG_LL_DBGU0
		bool "Kernel low-level debugging on rm9200, 9260/9g20, 9261/9g10 and 9rl"
		depends on HAVE_AT91_DBGU0

	config AT91_DEBUG_LL_DBGU1
		bool "Kernel low-level debugging on 9263 and 9g45"
		depends on HAVE_AT91_DBGU1

	config DEBUG_BCM2835
		bool "Kernel low-level debugging on BCM2835 PL011 UART"
		depends on ARCH_BCM2835
		select DEBUG_UART_PL01X

	config DEBUG_CLPS711X_UART1
		bool "Kernel low-level debugging messages via UART1"
		depends on ARCH_CLPS711X
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the first serial port on these devices.

	config DEBUG_CLPS711X_UART2
		bool "Kernel low-level debugging messages via UART2"
		depends on ARCH_CLPS711X
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the second serial port on these devices.

	config DEBUG_CNS3XXX
		bool "Kernel Kernel low-level debugging on Cavium Networks CNS3xxx"
		depends on ARCH_CNS3XXX
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want the debug print routines to direct
                  their output to the CNS3xxx UART0.

	config DEBUG_DAVINCI_DA8XX_UART1
		bool "Kernel low-level debugging on DaVinci DA8XX using UART1"
		depends on ARCH_DAVINCI_DA8XX
		select DEBUG_UART_8250
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART1 serial port on DaVinci DA8XX devices.

	config DEBUG_DAVINCI_DA8XX_UART2
		bool "Kernel low-level debugging on DaVinci DA8XX using UART2"
		depends on ARCH_DAVINCI_DA8XX
		select DEBUG_UART_8250
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART2 serial port on DaVinci DA8XX devices.

	config DEBUG_DAVINCI_DMx_UART0
		bool "Kernel low-level debugging on DaVinci DMx using UART0"
		depends on ARCH_DAVINCI_DMx
		select DEBUG_UART_8250
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART0 serial port on DaVinci DMx devices.

	config DEBUG_DAVINCI_TNETV107X_UART1
		bool "Kernel low-level debugging on DaVinci TNETV107x using UART1"
		depends on ARCH_DAVINCI_TNETV107X
		select DEBUG_UART_8250
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART1 serial port on DaVinci TNETV107X
		  devices.

	config DEBUG_ZYNQ_UART0
		bool "Kernel low-level debugging on Xilinx Zynq using UART0"
		depends on ARCH_ZYNQ
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART0 on the Zynq platform.

	config DEBUG_ZYNQ_UART1
		bool "Kernel low-level debugging on Xilinx Zynq using UART1"
		depends on ARCH_ZYNQ
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART1 on the Zynq platform.

		  If you have a ZC702 board and want early boot messages to
		  appear on the USB serial adaptor, select this option.

	config DEBUG_DC21285_PORT
		bool "Kernel low-level debugging messages via footbridge serial port"
		depends on FOOTBRIDGE
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the serial port in the DC21285 (Footbridge).

	config DEBUG_FOOTBRIDGE_COM1
		bool "Kernel low-level debugging messages via footbridge 8250 at PCI COM1"
		depends on FOOTBRIDGE
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the 8250 at PCI COM1.

	config DEBUG_HI3620_UART
		bool "Hisilicon HI3620 Debug UART"
		depends on ARCH_HI3xxx
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want kernel low-level debugging support
		  on HI3620 UART.

	config DEBUG_HI3716_UART
		bool "Hisilicon Hi3716 Debug UART"
		depends on ARCH_HI3xxx
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want kernel low-level debugging support
		  on HI3716 UART.

	config DEBUG_HIGHBANK_UART
		bool "Kernel low-level debugging messages via Highbank UART"
		depends on ARCH_HIGHBANK
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the UART on Highbank based devices.

	config DEBUG_IMX1_UART
		bool "i.MX1 Debug UART"
		depends on SOC_IMX1
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX1.

	config DEBUG_IMX23_UART
		bool "i.MX23 Debug UART"
		depends on SOC_IMX23
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX23.

	config DEBUG_IMX25_UART
		bool "i.MX25 Debug UART"
		depends on SOC_IMX25
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX25.

	config DEBUG_IMX21_IMX27_UART
		bool "i.MX21 and i.MX27 Debug UART"
		depends on SOC_IMX21 || SOC_IMX27
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX21 or i.MX27.

	config DEBUG_IMX28_UART
		bool "i.MX28 Debug UART"
		depends on SOC_IMX28
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX28.

	config DEBUG_IMX31_UART
		bool "i.MX31 Debug UART"
		depends on SOC_IMX31
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX31.

	config DEBUG_IMX35_UART
		bool "i.MX35 Debug UART"
		depends on SOC_IMX35
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX35.

	config DEBUG_IMX51_UART
		bool "i.MX51 Debug UART"
		depends on SOC_IMX51
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX51.

	config DEBUG_IMX53_UART
		bool "i.MX53 Debug UART"
		depends on SOC_IMX53
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX53.

	config DEBUG_IMX6Q_UART
		bool "i.MX6Q/DL Debug UART"
		depends on SOC_IMX6Q
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX6Q/DL.

	config DEBUG_IMX6SL_UART
		bool "i.MX6SL Debug UART"
		depends on SOC_IMX6SL
		help
		  Say Y here if you want kernel low-level debugging support
		  on i.MX6SL.

	config DEBUG_KEYSTONE_UART0
		bool "Kernel low-level debugging on KEYSTONE2 using UART0"
		depends on ARCH_KEYSTONE
		select DEBUG_UART_8250
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART0 serial port on KEYSTONE2 devices.

	config DEBUG_KEYSTONE_UART1
		bool "Kernel low-level debugging on KEYSTONE2 using UART1"
		depends on ARCH_KEYSTONE
		select DEBUG_UART_8250
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART1 serial port on KEYSTONE2 devices.

	config DEBUG_MMP_UART2
		bool "Kernel low-level debugging message via MMP UART2"
		depends on ARCH_MMP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on MMP UART2.

	config DEBUG_MMP_UART3
		bool "Kernel low-level debugging message via MMP UART3"
		depends on ARCH_MMP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on MMP UART3.

	config DEBUG_MSM_UART1
		bool "Kernel low-level debugging messages via MSM UART1"
		depends on ARCH_MSM7X00A || ARCH_MSM7X30 || ARCH_QSD8X50
		select DEBUG_MSM_UART
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the first serial port on MSM devices.

	config DEBUG_MSM_UART2
		bool "Kernel low-level debugging messages via MSM UART2"
		depends on ARCH_MSM7X00A || ARCH_MSM7X30 || ARCH_QSD8X50
		select DEBUG_MSM_UART
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the second serial port on MSM devices.

	config DEBUG_MSM_UART3
		bool "Kernel low-level debugging messages via MSM UART3"
		depends on ARCH_MSM7X00A || ARCH_MSM7X30 || ARCH_QSD8X50
		select DEBUG_MSM_UART
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the third serial port on MSM devices.

	config DEBUG_MSM8660_UART
		bool "Kernel low-level debugging messages via MSM 8660 UART"
		depends on ARCH_MSM8X60
		select MSM_HAS_DEBUG_UART_HS
		select DEBUG_MSM_UART
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the serial port on MSM 8660 devices.

	config DEBUG_MSM8960_UART
		bool "Kernel low-level debugging messages via MSM 8960 UART"
		depends on ARCH_MSM8960
		select MSM_HAS_DEBUG_UART_HS
		select DEBUG_MSM_UART
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the serial port on MSM 8960 devices.

	config DEBUG_MSM8974_UART
		bool "Kernel low-level debugging messages via MSM 8974 UART"
		depends on ARCH_MSM8974
		select MSM_HAS_DEBUG_UART_HS
		select DEBUG_MSM_UART
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the serial port on MSM 8974 devices.

	config DEBUG_MVEBU_UART
		bool "Kernel low-level debugging messages via MVEBU UART (old bootloaders)"
		depends on ARCH_MVEBU
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on MVEBU based platforms.

		  This option should be used with the old bootloaders
		  that left the internal registers mapped at
		  0xd0000000. As of today, this is the case on
		  platforms such as the Globalscale Mirabox or the
		  Plathome OpenBlocks AX3, when using the original
		  bootloader.

		  If the wrong DEBUG_MVEBU_UART* option is selected,
		  when u-boot hands over to the kernel, the system
		  silently crashes, with no serial output at all.

	config DEBUG_MVEBU_UART_ALTERNATE
		bool "Kernel low-level debugging messages via MVEBU UART (new bootloaders)"
		depends on ARCH_MVEBU
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on MVEBU based platforms.

		  This option should be used with the new bootloaders
		  that remap the internal registers at 0xf1000000.

		  If the wrong DEBUG_MVEBU_UART* option is selected,
		  when u-boot hands over to the kernel, the system
		  silently crashes, with no serial output at all.

	config DEBUG_VF_UART
		bool "Vybrid UART"
		depends on SOC_VF610
		help
		  Say Y here if you want kernel low-level debugging support
		  on Vybrid based platforms.

	config DEBUG_NOMADIK_UART
		bool "Kernel low-level debugging messages via NOMADIK UART"
		depends on ARCH_NOMADIK
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want kernel low-level debugging support
		  on NOMADIK based platforms.

	config DEBUG_NSPIRE_CLASSIC_UART
		bool "Kernel low-level debugging via TI-NSPIRE 8250 UART"
		depends on ARCH_NSPIRE
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on TI-NSPIRE classic models.

	config DEBUG_NSPIRE_CX_UART
		bool "Kernel low-level debugging via TI-NSPIRE PL011 UART"
		depends on ARCH_NSPIRE
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want kernel low-level debugging support
		  on TI-NSPIRE CX models.

	config DEBUG_OMAP2UART1
		bool "OMAP2/3/4 UART1 (omap2/3 sdp boards and some omap3 boards)"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART
		help
		  This covers at least h4, 2430sdp, 3430sdp, 3630sdp,
		  omap3 torpedo and 3530 lv som.

	config DEBUG_OMAP2UART2
		bool "Kernel low-level debugging messages via OMAP2/3/4 UART2"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_OMAP2UART3
		bool "Kernel low-level debugging messages via OMAP2 UART3 (n8x0)"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_OMAP3UART3
		bool "Kernel low-level debugging messages via OMAP3 UART3 (most omap3 boards)"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART
		help
		  This covers at least cm_t3x, beagle, crane, devkit8000,
		  igep00x0, ldp, n900, n9(50), pandora, overo, touchbook,
		  and 3517evm.

	config DEBUG_OMAP4UART3
		bool "Kernel low-level debugging messages via OMAP4/5 UART3 (omap4 blaze, panda, omap5 sevm)"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_OMAP3UART4
		bool "Kernel low-level debugging messages via OMAP36XX UART4"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_OMAP4UART4
		bool "Kernel low-level debugging messages via OMAP4/5 UART4"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_TI81XXUART1
		bool "Kernel low-level debugging messages via TI81XX UART1 (ti8148evm)"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_TI81XXUART2
		bool "Kernel low-level debugging messages via TI81XX UART2"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_TI81XXUART3
		bool "Kernel low-level debugging messages via TI81XX UART3 (ti8168evm)"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_AM33XXUART1
		bool "Kernel low-level debugging messages via AM33XX UART1"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_ZOOM_UART
		bool "Kernel low-level debugging messages via Zoom2/3 UART"
		depends on ARCH_OMAP2PLUS
		select DEBUG_OMAP2PLUS_UART

	config DEBUG_PICOXCELL_UART
		depends on ARCH_PICOXCELL
		bool "Use PicoXcell UART for low-level debug"
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on PicoXcell based platforms.

	config DEBUG_PXA_UART1
		depends on ARCH_PXA
		bool "Use PXA UART1 for low-level debug"
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on PXA UART1.

	config DEBUG_REALVIEW_STD_PORT
		bool "RealView Default UART"
		depends on ARCH_REALVIEW
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the serial port on RealView EB, PB11MP, PBA8
		  and PBX platforms.

	config DEBUG_REALVIEW_PB1176_PORT
		bool "RealView PB1176 UART"
		depends on MACH_REALVIEW_PB1176
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the standard serial port on the RealView
		  PB1176 platform.

	config DEBUG_RK29_UART0
		bool "Kernel low-level debugging messages via Rockchip RK29 UART0"
		depends on ARCH_ROCKCHIP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Rockchip based platforms.

	config DEBUG_RK29_UART1
		bool "Kernel low-level debugging messages via Rockchip RK29 UART1"
		depends on ARCH_ROCKCHIP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Rockchip based platforms.

	config DEBUG_RK29_UART2
		bool "Kernel low-level debugging messages via Rockchip RK29 UART2"
		depends on ARCH_ROCKCHIP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Rockchip based platforms.

	config DEBUG_RK3X_UART0
		bool "Kernel low-level debugging messages via Rockchip RK3X UART0"
		depends on ARCH_ROCKCHIP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Rockchip based platforms.

	config DEBUG_RK3X_UART1
		bool "Kernel low-level debugging messages via Rockchip RK3X UART1"
		depends on ARCH_ROCKCHIP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Rockchip based platforms.

	config DEBUG_RK3X_UART2
		bool "Kernel low-level debugging messages via Rockchip RK3X UART2"
		depends on ARCH_ROCKCHIP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Rockchip based platforms.

	config DEBUG_RK3X_UART3
		bool "Kernel low-level debugging messages via Rockchip RK3X UART3"
		depends on ARCH_ROCKCHIP
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Rockchip based platforms.

	config DEBUG_S3C_UART0
		depends on PLAT_SAMSUNG
		select DEBUG_EXYNOS_UART if ARCH_EXYNOS
		bool "Use S3C UART 0 for low-level debug"
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART 0. The port must have been initialised
		  by the boot-loader before use.

		  The uncompressor code port configuration is now handled
		  by CONFIG_S3C_LOWLEVEL_UART_PORT.

	config DEBUG_S3C_UART1
		depends on PLAT_SAMSUNG
		select DEBUG_EXYNOS_UART if ARCH_EXYNOS
		bool "Use S3C UART 1 for low-level debug"
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART 1. The port must have been initialised
		  by the boot-loader before use.

		  The uncompressor code port configuration is now handled
		  by CONFIG_S3C_LOWLEVEL_UART_PORT.

	config DEBUG_S3C_UART2
		depends on PLAT_SAMSUNG
		select DEBUG_EXYNOS_UART if ARCH_EXYNOS
		bool "Use S3C UART 2 for low-level debug"
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART 2. The port must have been initialised
		  by the boot-loader before use.

		  The uncompressor code port configuration is now handled
		  by CONFIG_S3C_LOWLEVEL_UART_PORT.

	config DEBUG_S3C_UART3
		depends on PLAT_SAMSUNG && ARCH_EXYNOS
		select DEBUG_EXYNOS_UART
		bool "Use S3C UART 3 for low-level debug"
		help
		  Say Y here if you want the debug print routines to direct
		  their output to UART 3. The port must have been initialised
		  by the boot-loader before use.

		  The uncompressor code port configuration is now handled
		  by CONFIG_S3C_LOWLEVEL_UART_PORT.

	config DEBUG_SOCFPGA_UART
		depends on ARCH_SOCFPGA
		bool "Use SOCFPGA UART for low-level debug"
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on SOCFPGA based platforms.

	config DEBUG_SUNXI_UART0
		bool "Kernel low-level debugging messages via sunXi UART0"
		depends on ARCH_SUNXI
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Allwinner A1X based platforms on the UART0.

	config DEBUG_SUNXI_UART1
		bool "Kernel low-level debugging messages via sunXi UART1"
		depends on ARCH_SUNXI
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Allwinner A1X based platforms on the UART1.

	config TEGRA_DEBUG_UART_AUTO_ODMDATA
		bool "Kernel low-level debugging messages via Tegra UART via ODMDATA"
		depends on ARCH_TEGRA
		select DEBUG_TEGRA_UART
		help
		  Automatically determines which UART to use for low-level
		  debug based on the ODMDATA value. This value is part of
		  the BCT, and is written to the boot memory device using
		  nvflash, or other flashing tool.  When bits 19:18 are 3,
		  then bits 17:15 indicate which UART to use; 0/1/2/3/4
		  are UART A/B/C/D/E.

	config TEGRA_DEBUG_UARTA
		bool "Kernel low-level debugging messages via Tegra UART A"
		depends on ARCH_TEGRA
		select DEBUG_TEGRA_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on Tegra based platforms.

	config TEGRA_DEBUG_UARTB
		bool "Kernel low-level debugging messages via Tegra UART B"
		depends on ARCH_TEGRA
		select DEBUG_TEGRA_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on Tegra based platforms.

	config TEGRA_DEBUG_UARTC
		bool "Kernel low-level debugging messages via Tegra UART C"
		depends on ARCH_TEGRA
		select DEBUG_TEGRA_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on Tegra based platforms.

	config TEGRA_DEBUG_UARTD
		bool "Kernel low-level debugging messages via Tegra UART D"
		depends on ARCH_TEGRA
		select DEBUG_TEGRA_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on Tegra based platforms.

	config TEGRA_DEBUG_UARTE
		bool "Kernel low-level debugging messages via Tegra UART E"
		depends on ARCH_TEGRA
		select DEBUG_TEGRA_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on Tegra based platforms.

	config DEBUG_SIRFPRIMA2_UART1
		bool "Kernel low-level debugging messages via SiRFprimaII UART1"
		depends on ARCH_PRIMA2
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the uart1 port on SiRFprimaII devices.

	config DEBUG_SIRFMARCO_UART1
		bool "Kernel low-level debugging messages via SiRFmarco UART1"
		depends on ARCH_MARCO
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the uart1 port on SiRFmarco devices.

	config STIH41X_DEBUG_ASC2
		bool "Use StiH415/416 ASC2 UART for low-level debug"
		depends on ARCH_STI
		select DEBUG_STI_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on STiH415/416 based platforms like b2000, which has
		  default UART wired up to ASC2.

		  If unsure, say N.

	config STIH41X_DEBUG_SBC_ASC1
		bool "Use StiH415/416 SBC ASC1 UART for low-level debug"
		depends on ARCH_STI
		select DEBUG_STI_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on STiH415/416 based platforms like b2020. which has
		  default UART wired up to SBC ASC1.

		  If unsure, say N.

	config DEBUG_U300_UART
		bool "Kernel low-level debugging messages via U300 UART0"
		depends on ARCH_U300
		select DEBUG_UART_PL01X
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the uart port on U300 devices.

	config DEBUG_UX500_UART
		depends on ARCH_U8500
		bool "Use Ux500 UART for low-level debug"
		help
		  Say Y here if you want kernel low-level debugging support
		  on Ux500 based platforms.

	config DEBUG_VEXPRESS_UART0_DETECT
		bool "Autodetect UART0 on Versatile Express Cortex-A core tiles"
		depends on ARCH_VEXPRESS && CPU_CP15_MMU
		help
		  This option enables a simple heuristic which tries to determine
		  the motherboard's memory map variant (original or RS1) and then
		  choose the relevant UART0 base address.

		  Note that this will only work with standard A-class core tiles,
		  and may fail with non-standard SMM or custom software models.

	config DEBUG_VEXPRESS_UART0_CA9
		bool "Use PL011 UART0 at 0x10009000 (V2P-CA9 core tile)"
		depends on ARCH_VEXPRESS
		select DEBUG_UART_PL01X
		help
		  This option selects UART0 at 0x10009000. Except for custom models,
		  this applies only to the V2P-CA9 tile.

	config DEBUG_VEXPRESS_UART0_RS1
		bool "Use PL011 UART0 at 0x1c090000 (RS1 complaint tiles)"
		depends on ARCH_VEXPRESS
		select DEBUG_UART_PL01X
		help
		  This option selects UART0 at 0x1c090000. This applies to most
		  of the tiles using the RS1 memory map, including all new A-class
		  core tiles, FPGA-based SMMs and software models.

	config DEBUG_VEXPRESS_UART0_CRX
		bool "Use PL011 UART0 at 0xb0090000 (Cortex-R compliant tiles)"
		depends on ARCH_VEXPRESS && !MMU
		select DEBUG_UART_PL01X
		help
		  This option selects UART0 at 0xb0090000. This is appropriate for
		  Cortex-R series tiles and SMMs, such as Cortex-R5 and Cortex-R7

	config DEBUG_VT8500_UART0
		bool "Use UART0 on VIA/Wondermedia SoCs"
		depends on ARCH_VT8500
		help
		  This option selects UART0 on VIA/Wondermedia System-on-a-chip
		  devices, including VT8500, WM8505, WM8650 and WM8850.

	config DEBUG_LL_UART_NONE
		bool "No low-level debugging UART"
		depends on !ARCH_MULTIPLATFORM
		help
		  Say Y here if your platform doesn't provide a UART option
		  above. This relies on your platform choosing the right UART
		  definition internally in order for low-level debugging to
		  work.

	config DEBUG_ICEDCC
		bool "Kernel low-level debugging via EmbeddedICE DCC channel"
		help
		  Say Y here if you want the debug print routines to direct
		  their output to the EmbeddedICE macrocell's DCC channel using
		  co-processor 14. This is known to work on the ARM9 style ICE
		  channel and on the XScale with the PEEDI.

		  Note that the system will appear to hang during boot if there
		  is nothing connected to read from the DCC.

	config DEBUG_SEMIHOSTING
		bool "Kernel low-level debug output via semihosting I/O"
		help
		  Semihosting enables code running on an ARM target to use
		  the I/O facilities on a host debugger/emulator through a
		  simple SVC call. The host debugger or emulator must have
		  semihosting enabled for the special svc call to be trapped
		  otherwise the kernel will crash.

		  This is known to work with OpenOCD, as well as
		  ARM's Fast Models, or any other controlling environment
		  that implements semihosting.

		  For more details about semihosting, please see
		  chapter 8 of DUI0203I_rvct_developer_guide.pdf from ARM Ltd.

	config DEBUG_LL_UART_8250
		bool "Kernel low-level debugging via 8250 UART"
		help
		  Say Y here if you wish the debug print routes to direct
		  their output to an 8250 UART.  You can use this option
		  to provide the parameters for the 8250 UART rather than
		  selecting one of the platform specific options above if
		  you know the parameters for the port.

		  This option is preferred over the platform specific
		  options; the platform specific options are deprecated
		  and will be soon removed.

	config DEBUG_LL_UART_EFM32
		bool "Kernel low-level debugging via efm32 UART"
		depends on ARCH_EFM32
		help
		  Say Y here if you want the debug print routines to direct
		  their output to an UART or USART port on efm32 based
		  machines. Use the following addresses for DEBUG_UART_PHYS:

		    0x4000c000 | USART0
		    0x4000c400 | USART1
		    0x4000c800 | USART2
		    0x4000e000 | UART0
		    0x4000e400 | UART1

	config DEBUG_LL_UART_PL01X
		bool "Kernel low-level debugging via ARM Ltd PL01x Primecell UART"
		help
		  Say Y here if you wish the debug print routes to direct
		  their output to a PL01x Primecell UART.  You can use
		  this option to provide the parameters for the UART
		  rather than selecting one of the platform specific
		  options above if you know the parameters for the port.

		  This option is preferred over the platform specific
		  options; the platform specific options are deprecated
		  and will be soon removed.

endchoice

config DEBUG_EXYNOS_UART
	bool

config DEBUG_OMAP2PLUS_UART
	bool
	depends on ARCH_OMAP2PLUS

config DEBUG_IMX_UART_PORT
	int "i.MX Debug UART Port Selection" if DEBUG_IMX1_UART || \
						DEBUG_IMX25_UART || \
						DEBUG_IMX21_IMX27_UART || \
						DEBUG_IMX31_UART || \
						DEBUG_IMX35_UART || \
						DEBUG_IMX51_UART || \
						DEBUG_IMX53_UART || \
						DEBUG_IMX6Q_UART || \
						DEBUG_IMX6SL_UART
	default 1
	depends on ARCH_MXC
	help
	  Choose UART port on which kernel low-level debug messages
	  should be output.

config DEBUG_TEGRA_UART
	bool
	depends on ARCH_TEGRA

config DEBUG_STI_UART
	bool
	depends on ARCH_STI

config DEBUG_MSM_UART
	bool
	depends on ARCH_MSM

config DEBUG_LL_INCLUDE
	string
	default "debug/8250.S" if DEBUG_LL_UART_8250 || DEBUG_UART_8250
	default "debug/pl01x.S" if DEBUG_LL_UART_PL01X || DEBUG_UART_PL01X
	default "debug/exynos.S" if DEBUG_EXYNOS_UART
	default "debug/efm32.S" if DEBUG_LL_UART_EFM32
	default "debug/icedcc.S" if DEBUG_ICEDCC
	default "debug/imx.S" if DEBUG_IMX1_UART || \
				 DEBUG_IMX25_UART || \
				 DEBUG_IMX21_IMX27_UART || \
				 DEBUG_IMX31_UART || \
				 DEBUG_IMX35_UART || \
				 DEBUG_IMX51_UART || \
				 DEBUG_IMX53_UART ||\
				 DEBUG_IMX6Q_UART || \
				 DEBUG_IMX6SL_UART
	default "debug/msm.S" if DEBUG_MSM_UART
	default "debug/omap2plus.S" if DEBUG_OMAP2PLUS_UART
	default "debug/sirf.S" if DEBUG_SIRFPRIMA2_UART1 || DEBUG_SIRFMARCO_UART1
	default "debug/sti.S" if DEBUG_STI_UART
	default "debug/tegra.S" if DEBUG_TEGRA_UART
	default "debug/ux500.S" if DEBUG_UX500_UART
	default "debug/vexpress.S" if DEBUG_VEXPRESS_UART0_DETECT
	default "debug/vf.S" if DEBUG_VF_UART
	default "debug/vt8500.S" if DEBUG_VT8500_UART0
	default "debug/zynq.S" if DEBUG_ZYNQ_UART0 || DEBUG_ZYNQ_UART1
	default "mach/debug-macro.S"

# Compatibility options for PL01x
config DEBUG_UART_PL01X
	def_bool ARCH_EP93XX || \
		ARCH_INTEGRATOR || \
		ARCH_SPEAR3XX || \
		ARCH_SPEAR6XX || \
		ARCH_SPEAR13XX || \
		ARCH_VERSATILE

# Compatibility options for 8250
config DEBUG_UART_8250
	def_bool ARCH_DOVE || ARCH_EBSA110 || \
		(FOOTBRIDGE && !DEBUG_DC21285_PORT) || \
		ARCH_GEMINI || ARCH_IOP13XX || ARCH_IOP32X || \
		ARCH_IOP33X || ARCH_IXP4XX || ARCH_KIRKWOOD || \
		ARCH_LPC32XX || ARCH_MV78XX0 || ARCH_ORION5X || ARCH_RPC

config DEBUG_UART_PHYS
	hex "Physical base address of debug UART"
	default 0x01c20000 if DEBUG_DAVINCI_DMx_UART0
	default 0x01c28000 if DEBUG_SUNXI_UART0
	default 0x01c28400 if DEBUG_SUNXI_UART1
	default 0x01d0c000 if DEBUG_DAVINCI_DA8XX_UART1
	default 0x01d0d000 if DEBUG_DAVINCI_DA8XX_UART2
	default 0x02530c00 if DEBUG_KEYSTONE_UART0
	default 0x02531000 if DEBUG_KEYSTONE_UART1
	default 0x03010fe0 if ARCH_RPC
	default 0x08108300 if DEBUG_DAVINCI_TNETV107X_UART1
	default 0x10009000 if DEBUG_REALVIEW_STD_PORT || DEBUG_CNS3XXX || \
				DEBUG_VEXPRESS_UART0_CA9
	default 0x1010c000 if DEBUG_REALVIEW_PB1176_PORT
	default 0x10124000 if DEBUG_RK3X_UART0
	default 0x10126000 if DEBUG_RK3X_UART1
	default 0x101f1000 if ARCH_VERSATILE
	default 0x101fb000 if DEBUG_NOMADIK_UART
	default 0x16000000 if ARCH_INTEGRATOR
	default 0x1c090000 if DEBUG_VEXPRESS_UART0_RS1
	default 0x20060000 if DEBUG_RK29_UART0
	default 0x20064000 if DEBUG_RK29_UART1 || DEBUG_RK3X_UART2
	default 0x20068000 if DEBUG_RK29_UART2 || DEBUG_RK3X_UART3
	default 0x20201000 if DEBUG_BCM2835
	default 0x4000e400 if DEBUG_LL_UART_EFM32
	default 0x40090000 if ARCH_LPC32XX
	default 0x40100000 if DEBUG_PXA_UART1
	default 0x42000000 if ARCH_GEMINI
	default 0x7c0003f8 if FOOTBRIDGE
	default 0x80230000 if DEBUG_PICOXCELL_UART
	default 0x80070000 if DEBUG_IMX23_UART
	default 0x80074000 if DEBUG_IMX28_UART
	default 0x808c0000 if ARCH_EP93XX
	default 0x90020000 if DEBUG_NSPIRE_CLASSIC_UART || DEBUG_NSPIRE_CX_UART
	default 0xb0090000 if DEBUG_VEXPRESS_UART0_CRX
	default 0xc0013000 if DEBUG_U300_UART
	default 0xc8000000 if ARCH_IXP4XX && !CPU_BIG_ENDIAN
	default 0xc8000003 if ARCH_IXP4XX && CPU_BIG_ENDIAN
	default 0xd0000000 if ARCH_SPEAR3XX || ARCH_SPEAR6XX
	default 0xd0012000 if DEBUG_MVEBU_UART
	default 0xd4017000 if DEBUG_MMP_UART2
	default 0xd4018000 if DEBUG_MMP_UART3
	default 0xe0000000 if ARCH_SPEAR13XX
	default 0xf0000be0 if ARCH_EBSA110
	default 0xf1012000 if DEBUG_MVEBU_UART_ALTERNATE
	default 0xf1012000 if ARCH_DOVE || ARCH_KIRKWOOD || ARCH_MV78XX0 || \
				ARCH_ORION5X
	default 0xf8b00000 if DEBUG_HI3716_UART
	default 0xfcb00000 if DEBUG_HI3620_UART
	default 0xfe800000 if ARCH_IOP32X
	default 0xffc02000 if DEBUG_SOCFPGA_UART
	default 0xffd82340 if ARCH_IOP13XX
	default 0xfff36000 if DEBUG_HIGHBANK_UART
	default 0xfffff700 if ARCH_IOP33X
	depends on DEBUG_LL_UART_8250 || DEBUG_LL_UART_PL01X || \
		DEBUG_LL_UART_EFM32 || \
		DEBUG_UART_8250 || DEBUG_UART_PL01X

config DEBUG_UART_VIRT
	hex "Virtual base address of debug UART"
	default 0xe0010fe0 if ARCH_RPC
	default 0xf0000be0 if ARCH_EBSA110
	default 0xf0009000 if DEBUG_CNS3XXX
	default 0xf01fb000 if DEBUG_NOMADIK_UART
	default 0xf0201000 if DEBUG_BCM2835
	default 0xf11f1000 if ARCH_VERSATILE
	default 0xf1600000 if ARCH_INTEGRATOR
	default 0xf1c28000 if DEBUG_SUNXI_UART0
	default 0xf1c28400 if DEBUG_SUNXI_UART1
	default 0xf2100000 if DEBUG_PXA_UART1
	default 0xf4090000 if ARCH_LPC32XX
	default 0xf4200000 if ARCH_GEMINI
	default 0xf8009000 if DEBUG_VEXPRESS_UART0_CA9
	default 0xf8090000 if DEBUG_VEXPRESS_UART0_RS1
	default 0xfb009000 if DEBUG_REALVIEW_STD_PORT
	default 0xfb10c000 if DEBUG_REALVIEW_PB1176_PORT
	default 0xfd000000 if ARCH_SPEAR3XX || ARCH_SPEAR6XX
	default 0xfd000000 if ARCH_SPEAR13XX
	default 0xfd012000 if ARCH_MV78XX0
	default 0xfde12000 if ARCH_DOVE
	default 0xfe012000 if ARCH_ORION5X
	default 0xfe017000 if DEBUG_MMP_UART2
	default 0xfe018000 if DEBUG_MMP_UART3
	default 0xfe100000 if DEBUG_IMX23_UART || DEBUG_IMX28_UART
	default 0xfe230000 if DEBUG_PICOXCELL_UART
	default 0xfe800000 if ARCH_IOP32X
	default 0xfeb00000 if DEBUG_HI3620_UART || DEBUG_HI3716_UART
	default 0xfeb24000 if DEBUG_RK3X_UART0
	default 0xfeb26000 if DEBUG_RK3X_UART1
	default 0xfeb30c00 if DEBUG_KEYSTONE_UART0
	default 0xfeb31000 if DEBUG_KEYSTONE_UART1
	default 0xfec12000 if DEBUG_MVEBU_UART || DEBUG_MVEBU_UART_ALTERNATE
	default 0xfed60000 if DEBUG_RK29_UART0
	default 0xfed64000 if DEBUG_RK29_UART1 || DEBUG_RK3X_UART2
	default 0xfed68000 if DEBUG_RK29_UART2 || DEBUG_RK3X_UART3
	default 0xfec02000 if DEBUG_SOCFPGA_UART
	default 0xfec20000 if DEBUG_DAVINCI_DMx_UART0
	default 0xfed0c000 if DEBUG_DAVINCI_DA8XX_UART1
	default 0xfed0d000 if DEBUG_DAVINCI_DA8XX_UART2
	default 0xfed12000 if ARCH_KIRKWOOD
	default 0xfedc0000 if ARCH_EP93XX
	default 0xfee003f8 if FOOTBRIDGE
	default 0xfee08300 if DEBUG_DAVINCI_TNETV107X_UART1
	default 0xfee20000 if DEBUG_NSPIRE_CLASSIC_UART || DEBUG_NSPIRE_CX_UART
	default 0xfef36000 if DEBUG_HIGHBANK_UART
	default 0xfee82340 if ARCH_IOP13XX
	default 0xfef00000 if ARCH_IXP4XX && !CPU_BIG_ENDIAN
	default 0xfef00003 if ARCH_IXP4XX && CPU_BIG_ENDIAN
	default 0xfefff700 if ARCH_IOP33X
	default 0xff003000 if DEBUG_U300_UART
	default DEBUG_UART_PHYS if !MMU
	depends on DEBUG_LL_UART_8250 || DEBUG_LL_UART_PL01X || \
		DEBUG_UART_8250 || DEBUG_UART_PL01X

config DEBUG_UART_8250_SHIFT
	int "Register offset shift for the 8250 debug UART"
	depends on DEBUG_LL_UART_8250 || DEBUG_UART_8250
	default 0 if FOOTBRIDGE || ARCH_IOP32X
	default 2

config DEBUG_UART_8250_WORD
	bool "Use 32-bit accesses for 8250 UART"
	depends on DEBUG_LL_UART_8250 || DEBUG_UART_8250
	depends on DEBUG_UART_8250_SHIFT >= 2
	default y if DEBUG_PICOXCELL_UART || DEBUG_SOCFPGA_UART || \
		ARCH_KEYSTONE || \
		DEBUG_DAVINCI_DMx_UART0 || DEBUG_DAVINCI_DA8XX_UART1 || \
		DEBUG_DAVINCI_DA8XX_UART2 || DEBUG_DAVINCI_TNETV107X_UART1

config DEBUG_UART_8250_FLOW_CONTROL
	bool "Enable flow control for 8250 UART"
	depends on DEBUG_LL_UART_8250 || DEBUG_UART_8250
	default y if ARCH_EBSA110 || FOOTBRIDGE || ARCH_GEMINI || ARCH_RPC

config DEBUG_UNCOMPRESS
	bool
	depends on ARCH_MULTIPLATFORM || ARCH_MSM
	default y if DEBUG_LL && !DEBUG_OMAP2PLUS_UART && \
		     (!DEBUG_TEGRA_UART || !ZBOOT_ROM)
	help
	  This option influences the normal decompressor output for
	  multiplatform kernels.  Normally, multiplatform kernels disable
	  decompressor output because it is not possible to know where to
	  send the decompressor output.

	  When this option is set, the selected DEBUG_LL output method
	  will be re-used for normal decompressor output on multiplatform
	  kernels.
	  

config UNCOMPRESS_INCLUDE
	string
	default "debug/uncompress.h" if ARCH_MULTIPLATFORM || ARCH_MSM
	default "mach/uncompress.h"

config EARLY_PRINTK
	bool "Early printk"
	depends on DEBUG_LL
	help
	  Say Y here if you want to have an early console using the
	  kernel low-level debugging functions. Add earlyprintk to your
	  kernel parameters to enable this console.

config OC_ETM
	bool "On-chip ETM and ETB"
	depends on ARM_AMBA
	help
	  Enables the on-chip embedded trace macrocell and embedded trace
	  buffer driver that will allow you to collect traces of the
	  kernel code.

config ARM_KPROBES_TEST
	tristate "Kprobes test module"
	depends on KPROBES && MODULES
	help
	  Perform tests of kprobes API and instruction set simulation.

config PID_IN_CONTEXTIDR
	bool "Write the current PID to the CONTEXTIDR register"
	depends on CPU_COPY_V6
	help
	  Enabling this option causes the kernel to write the current PID to
	  the PROCID field of the CONTEXTIDR register, at the expense of some
	  additional instructions during context switch. Say Y here only if you
	  are planning to use hardware trace tools with this kernel.

endmenu
